import base64
import hashlib
from uuid import UUID
from datetime import datetime, UTC, timedelta
from pydantic import BaseModel

from common import settings
from ..repository.models.common import User, UserCreate
from ..repository.models.auth import RefreshToken
from .exceptions import *


AUTH_CODE_TEMPLATE = 'auth-code:{0}'
LOGIN_BLOCKS_TEMPLATE = 'login-blocks:{0}'


class CodeData(BaseModel):
    """ Data stored when requesting an authorization code """
    user_id: UUID | None = None
    privilege: str | None = None
    challenge: str | None = None
    state: str | None = None


class TokenFamily(BaseModel):
    """ The entity returned as an artifact when requesting or updating a token """
    access: str
    access_expires_in_secs: int
    refresh: str
    csrf: str


class UserBlock(BaseModel):
    """ User login status.
    attempts - number of failed attempts
    blocked_until - user login blocked until. None if not blocked
    """
    attempts: int = 0
    blocked_until: datetime | None = None


class AuthSystem:
    """ System of authorize and generating access tokens """
    def __init__(self, token_manager, repo, redis, hasher):
        """ Initializer
        :param token_manager: token generator
        :param repo: async repository
        :param redis: redis storage. used for save temporary data
        :param hasher: crypt hasher
        """
        self.token_manager = token_manager
        self.repo = repo
        self.redis = redis
        self.hasher = hasher

    async def authorize(self, session, username: str, password: str, code_challenge: str, state: str) -> tuple[str, str]:
        """ Perform user authorization and issue an OAuth2 authorization code.

        This method implements the Authorization Code flow (OAuth 2.0) with PKCE.
        It authenticates the user using username and password, applies brute-force
        protection, and issues a short-lived, single-use authorization code.

        The authorization code is stored in a temporary storage (Redis) together
        with the PKCE code challenge and client-provided state value. The code can
        later be exchanged for an access token and refresh token.

        Security guarantees:
        - Applies brute-force protection on login attempts
        - Verifies user credentials using a password hash
        - Issues a short-lived authorization code with TTL
        - Binds the authorization code to a PKCE code challenge
        - Preserves the `state` value to protect against CSRF attacks
        - The authorization code is intended to be single-use

        :param session: An active database session used to load user data.
        :param username: User login identifier.
        :param password: Plain-text user password (validated against stored password hash).
        :param code_challenge: PKCE code challenge derived from the client's code verifier.
        Stored together with the authorization code and verified during the token exchange step.
        :param state: Opaque client-provided value that will be returned unchanged.
        Used by the client to correlate requests and protect against CSRF.

        :return tuple[str, str]:
                - authorization code: a short-lived code that can be exchanged for tokens
                - state: the same state value provided by the client

        :raises: TooManyAttempts: If the user is temporarily blocked due to repeated failed authentication attempts.
        :raises: InvalidCredentials: If the username does not exist or the password is incorrect.
        """
        blocked = await self._user_is_blocked(username)
        if blocked:
            raise TooManyAttempts(blocked.blocked_until)

        user = await self.repo.get_user(session, login=username)
        if not user or not await self.hasher.verify(password, user.password_hash):
            await self._fail_attempt(username)
            raise InvalidCredentials()

        await self._reset_attempts(username)

        code = self.token_manager.generate_simple_token()
        code_data = CodeData(user_id=user.id, privilege=user.privilege, challenge=code_challenge, state=state)
        topic = AUTH_CODE_TEMPLATE.format(code)
        await self.redis.add_dict(topic=topic, data=code_data.model_dump(), ttl_secs=settings.code_ttl_secs)

        return code, state

    async def token(self, session, code: str, code_verifier: str, state: str) -> TokenFamily:
        """ Exchange an OAuth2 authorization code for an access token and refresh token.
        Validate the authorization code, enforce single-use semantics, and verify
        PKCE and state values before issuing tokens.

        :param session: opened database session
        :param code: authorization code previously issued by the authorize method
        :param code_verifier: PKCE code verifier generated by the client
        :param state: state value provided during authorization, used to protect against CSRF and to correlate requests

        :return: TokenFamily containing a newly issued access token, refresh token, and CSRF token

        :raises InvalidCode: if the authorization code does not exist, has already been used, has expired,
        or the state value does not match
        :raises CodeAlreadyUsed: if the authorization code already used
        :raises PkceFailed: if PKCE verification fails
        """
        topic = AUTH_CODE_TEMPLATE.format(code)
        code_data = self._model_or_none(CodeData, await self.redis.get_dict(topic=topic))
        if not code_data or code_data.state != state:
            raise InvalidCode()

        if not await self.redis.set_unique(topic=f'{topic}:used', value=True, ttl_secs=settings.code_ttl_secs):
            raise CodeAlreadyUsed()

        if not self._verify_pkce(code_verifier, code_data.challenge):
            raise PkceFailed()

        await self.redis.add_dict(topic=topic, data=code_data.model_dump(), ttl_secs=settings.code_ttl_secs)

        token_family = self._create_token_family(str(code_data.user_id), code_data.privilege)

        await self.repo.create_token(session, RefreshToken(token=token_family.refresh, csrf=token_family.csrf, user_id=code_data.user_id))

        return token_family

    async def refresh(self, session, token: str, csrf_cookie: str, csrf_header: str) -> TokenFamily:
        """ Exchange a valid refresh token for a new token family using refresh token
        rotation and CSRF protection. Detect reuse of revoked tokens and invalidate all user sessions on reuse attempt.

        :param session: opened database session
        :param token: refresh token used to obtain a new access token
        :param csrf_cookie: CSRF token from cookie bound to the refresh token and required to confirm the refresh request
        :param csrf_header: CSRF token from header bound to the refresh token and required to confirm the refresh request

        :return: TokenFamily containing a new access token, refresh token, and CSRF token

        :raises RefreshUnknownToken: if the refresh token does not exist
        :raises RefreshReuseDetected: if the refresh token has already been revoked;
        indicates refresh token reuse and triggers revocation of all user refresh tokens
        :raises RefreshTokenExpired: if the refresh token has expired
        :raises CsrfFailed: if the provided CSRF token does not match the stored one
        """
        async with session.begin():
            rec = await self.repo.get_token_for_update(session=session, token=token)
            if not rec:
                raise RefreshUnknownToken()

            if rec.revoked:
                self._mark_as_revoked(rec.user.refresh_tokens)
                raise RefreshReuseDetected()

            if rec.expires < datetime.now():
                raise RefreshTokenExpired()

            if not csrf_cookie or not csrf_header or csrf_cookie != csrf_header or csrf_cookie != rec.csrf:
                raise CsrfFailed()

            self._mark_as_revoked([rec])

            token_family = self._create_token_family(str(rec.user_id), rec.user.privilege)

            await self.repo.create_token(session, RefreshToken(token=token_family.refresh,
                                                               csrf=token_family.csrf,
                                                               user_id=rec.user_id))

        return token_family

    async def revoke_one(self, session, token: str) -> None:
        """ Revoke a single refresh token by marking it as revoked. The operation is idempotent: calling it
        multiple times for the same token produces the same final state.

        :param session: opened database session
        :param token: refresh token to revoke

        :return: None
        """
        async with session.begin():
            rec = await self.repo.get_token_for_update(session=session, token=token)
            if rec:
                self._mark_as_revoked([rec])

    async def revoke_all(self, session, token: str) -> None:
        """ Revoke all refresh tokens belonging to the user associated with the given token.
        This is typically used when a token reuse is detected or the user performs a global logout.
        The operation is idempotent: multiple calls will produce the same final state.

        :param session: opened database session
        :param token: any refresh token belonging to the user; all tokens for this user will be revoked

        :return: None
        """
        async with session.begin():
            rec = await self.repo.get_token(session, token)
            if rec:
                tokens = await self.repo.get_user_tokens_for_update(session=session, user_id=rec.user_id)
                self._mark_as_revoked(tokens)

    async def registration(self, session, new_user: User | UserCreate) -> User:
        """ Register a new user by creating an account with a unique login and hashed password.
        Performs validation of login and password strength before storing the user.

        :param session: opened database session
        :param new_user: User or UserCreate object containing login and password

        :return: newly created User object with hashed password

        :raises LoginAlreadyUsed: if a user with the same login already exists
        :raises RegistrationError: if the login or password does not meet validation requirements
        """
        # TODO add limit for creating user from same ip
        existing_user = await self.repo.get_user(session=session, login=new_user.login)
        if existing_user:
            raise LoginAlreadyUsed()

        if not self._login_is_valid(new_user.login) or not self._password_is_valid(new_user.password):
            raise RegistrationError()

        user = User.model_validate(new_user)
        user.password_hash = await self.hasher.hash(new_user.password)
        return await self.repo.create_user(session=session, new_user=user)

    async def user_by_token(self, session, token: str) -> User:
        """ Get user model by token
        :param session: opened database session
        :param token: access token

        :return: User model object

        :raises UserNotFound: if user not found by token payload
        """
        payload = self.token_manager.decode(token)
        user = await self.repo.get_user(session, uid=UUID(payload.sub))
        if not user:
            raise UserNotFound()
        return user

    async def _user_is_blocked(self, username: str) -> UserBlock | None:
        """ Check if a user is blocked
        :param username: User login identifier
        :return: UserBlock object or None
        """
        topic = LOGIN_BLOCKS_TEMPLATE.format(username)
        block = self._model_or_none(UserBlock, await self.redis.get_dict(topic=topic))
        if block and block.blocked_until and block.blocked_until > datetime.now(UTC):
            return block
        else:
            return None

    async def _fail_attempt(self, username: str) -> None:
        """ Record a failed login attempt for a user and apply temporary blocking if
        the number of consecutive failed attempts exceeds the configured threshold.

        :param username: User login identifier
        """
        topic = LOGIN_BLOCKS_TEMPLATE.format(username)
        block = self._model_or_none(UserBlock, await self.redis.get_dict(topic=topic))
        if block is None:
            block = UserBlock()

        block.attempts += 1
        if block.attempts >= settings.login_attempts_before_block:
            block.blocked_until = datetime.now(UTC) + timedelta(minutes=settings.login_block_time_minutes)
            block.attempts = 0

        await self.redis.add_dict(topic=topic, data=block.model_dump(), ttl=settings.login_block_time_minutes * 60)

    async def _reset_attempts(self, username: str) -> None:
        """ Reset user login attempts """
        await self.redis.delete_dict(topic=LOGIN_BLOCKS_TEMPLATE.format(username))

    @staticmethod
    def _mark_as_revoked(tokens: list[RefreshToken]) -> None:
        """ Mark all tokens as revoked """
        for token in tokens:
            token.revoked = True

    @staticmethod
    def _verify_pkce(verifier: str, challenge: str) -> bool:
        digest = hashlib.sha256(verifier.encode()).digest()
        url = base64.urlsafe_b64encode(digest).rstrip(b'=').decode()
        return url == challenge

    @staticmethod
    def _login_is_valid(login: str) -> bool:
        return bool(' ' not in login and 3 < len(login) < 64)

    @staticmethod
    def _password_is_valid(password: str) -> bool:
        return bool(6 < len(password) < 72  and
                    (not password.islower() and not password.isupper()) and
                    any(str(d) in password for d in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)))

    @staticmethod
    def _model_or_none(model_type, kwargs) -> BaseModel | None:
        """ Create model from kwargs. If kwargs is not dict return None
        :param model_type: type of model for create
        :param kwargs: model fields with values
        """
        if isinstance(kwargs, dict):
            return model_type(**kwargs)
        else:
            return None

    def _create_token_family(self, user_id: str, privilege: str) -> TokenFamily:
        """ Create token family collection. Collection contains access, refresh and csrf tokens
        :param user_id: user login identifier
        :param privilege: user privileges
        :return: TokenFamily
        """
        access = self.token_manager.create_access_token(user_id, {'privilege': privilege})
        refresh = self.token_manager.create_simple_token()
        csrf = self.token_manager.create_simple_token()
        return TokenFamily(access=access, refresh=refresh, csrf=csrf, access_expires_in_secs=settings.access_token_ttl_minutes * 60)
